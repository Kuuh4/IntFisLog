/* autogenerated by Processing revision 1286 on 2022-11-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class V5 extends PApplet {

//declaração os usos da classe nova (pra alocar as variáveis delas)
Bola[] bolas = new Bola[50];

float var_arrancada = 0.5f;//escrever esse valor como um valor de 0=>1, sendo que ele vai ser o maior valor da arrancada

float tam_tela_min;
float diagonal_tela;
int backgroundx;
boolean switch_bg;

int pos_x;
int pos_y;

int main_color = color(255, 255, 255);
int gradA_color = color(255, 255, 255);
int gradB_color = color(255, 0, 0);


 public void setup() {
    //size(300,300);
    //fullScreen();

    //size(500,400,P2D);
    /* size commented out by preprocessor */;
    
    diagonal_tela = dist(0,0,width,height);
    tam_tela_min = min(width,height);
    backgroundx=0;
    
    //criação do objeto
    formulaArrancada_D(); //escolher a formula de arrancada. tem a _A _B e _Debug atualmente
    
    
    noCursor();
    noStroke();
}

 public void draw() {

    input_mouse();
    
    planodefundo();
    bolasseguirem_normal_v0();
    bolamouse_1();

}

 public void mouseClicked(){
    input_pos_aleatorio();
}
class Bola{
    //variáveis declaradas
    float arrancada, diameter;
    float x, y, dx, dy, targetx, targety, distancia_pos, variacao_cor, variacao_size;

//constructors
    Bola(float tempArrancada){
        //conversão da variável de argumento (temporária) para uma variável de fato (inicializando ela)
        arrancada = tempArrancada;
        diameter = tam_tela_min/8;
      
    }

    Bola(float tempArrancada,float tempDiameter){
        //conversão da variável de argumento (temporária) para uma variável de fato (inicializando ela)
        arrancada = tempArrancada;
        diameter = tempDiameter;
    }
    

//Functions

     public void update_v1(){

        /* CHANGELOG V1

            Alteração no comportamento do tamanho das bolas p/ exponencial

        */

        //inicializando e usando as variáveis
        
        targetx = pos_x; targety = pos_y;
        dx = targetx - x; dy = targety - y;
        
        //calculando a distancia linear da bola ate o mouse
        distancia_pos = dist(pos_x,pos_y,x,y);
        
        //calculando a posicao da bola / determinando o comportamento
        if (distancia_pos>=0.5f){
            x += dx * arrancada; y += dy * arrancada;
            //criando uma variacao de valores de 0 para 1 baseado na distancia e tamanho da tela
            variacao_cor = distancia_pos/(tam_tela_min/2);
        } else {
            x = pos_x; y = pos_y;
            variacao_cor = distancia_pos/tam_tela_min;
        }

        
        /*
        variação de tamanho de 0 à 1
         (função em distância do alvo) / (max distancia do alvo) 
        */
        variacao_size = 
        
            distancia_pos 
            
            / 
            
            diagonal_tela;
        

        //noFill();
        fill(lerpColor(gradA_color, gradB_color, variacao_cor));

        //usando as variáveis
        ellipse(x, y, diameter*(1-variacao_size), diameter*(1-variacao_size));
    }

     public void update_v0(){

        //inicializando e usando as variáveis
        
        targetx = pos_x; targety = pos_y;
        dx = targetx - x; dy = targety - y;
        
        //calculando a distancia linear da bola ate o mouse
        distancia_pos = dist(pos_x,pos_y,x,y);
        
        //calculando a posicao da bola
        if (distancia_pos>=0.5f){
            x += dx * arrancada; y += dy * arrancada;
            //criando uma variacao de valores de 0 para 1 baseado na distancia e tamanho da tela
            variacao_cor = distancia_pos/(tam_tela_min/2);
        } else {
            x = pos_x; y = pos_y;
            variacao_cor = distancia_pos/tam_tela_min;
        }

        variacao_size = distancia_pos/diagonal_tela;
        
        //noFill();
        fill(lerpColor(gradA_color, gradB_color, variacao_cor));

        //usando as variáveis
        ellipse(x, y, diameter*(1-variacao_size), diameter*(1-variacao_size));
    }
}

//PROCESSO DO VOID SETUP, OCORRE SOMENTE 1x PRA ALOCAR MEMÓRIA. NÂO INTERFERE EM VOIDDRAW()

//Código Chamado dentro de void setup()
//Fórmulas de variação de aceleração para construtor de Bola() baseado na quantidade de bolas.

 public void formulaArrancada_Debug(){
    //fazer gráfico invertido modular em x tbm.

    //fiz algum progresso na inversão. agora falta conseguir mover o cruzamento de todos os pontos na linha x de forma constante, sem depender do valor de X. 
    //https://www.desmos.com/calculator/9t9p5xfscq

    for (int i = 0; i < bolas.length; ++i) {
            bolas[i] = new Bola(1);
        }

}




 public void formulaArrancada_D(){
    //Cada vez menos arrancada linearmente
    //Alguns valores legais:
    //10 bolas, var arrancada 0.5   
        for (int i = 0; i < bolas.length; ++i) {
            bolas[i] = new Bola( 

                        /*
                        gráficos interativos da modulação matemática
                        https://www.desmos.com/calculator/dh7ydwox51
                        
                        AS VARIAVEIS i e bolas.length SÃO INT, TEM QUE COLOCAR ELAS DENTRO DO float(int)
                        Senão os valores são calculados como 0

                        var_arrancada é um valor para alterar de 1 para baixo o valor máximo de arrancada
                        
                        Diferente dos outros, com esse a gente conseguiria ter o contole da arrancada mínima e máxima
                        
                        */
                
                        ((((1/(PApplet.parseFloat(bolas.length)+1))*(-((PApplet.parseFloat(i))+1)))+1)*(var_arrancada))
                                            
                        );
        }
}

 public void formulaArrancada_C(){
    //Cada vez menos arrancada linearmente   
        for (int i = 0; i < bolas.length; ++i) {
            bolas[i] = new Bola(var_arrancada/(2*(PApplet.parseFloat(i)+1)));
        }
}

 public void formulaArrancada_B(){
    //Cada vez menos arrancada         
        for (int i = 0; i < bolas.length; ++i) {
            bolas[i] = new Bola(
                
                //Função Logarítimica [ 1 / exponencial ]

                    var_arrancada
                    /
                    pow(2,i)
                
                );
        }
}

 public void formulaArrancada_A(){
    //Cada vez menos arrancada linearmente   
        for (int i = 0; i < bolas.length; ++i) {
            bolas[i] = new Bola(
                
                //Função Logarítimica [ 1 / exponencial ]

                    1
                    /
                    ( (pow(2, 2)) * (i+1) )
                ) ;
        }
}
// Funções do código principal

//Bola que representa o mouse
    
    //V1 - tem o mesmo tamanho de bolas[0]
     public void bolamouse_1(){
        fill(main_color);
        ellipse(pos_x, pos_y, bolas[0].diameter*(1-bolas[0].variacao_size), bolas[0].diameter*(1-bolas[0].variacao_size));
    }
    
    //V0 - Tamanho Fixo
     public void bolamouse_0(){
        fill(main_color);
        ellipse(pos_x, pos_y, bolas[0].diameter, bolas[0].diameter);
    }


//Variações da função que desenha as bolas na tela a cada frame.
    
    //ESTRUTURA DO NOME DAS VARIANTES
        // "bolasseguirem_"+"normal/invertido"+"Versão do update"
            // Normal / invertido: Se referem à qual ordem as bolas são renderizadas
            // Versão do update: variações da função que determina o comportamento das bolas 
    
    //V0

     public void bolasseguirem_normal_v0(){
    
            for (int i = (bolas.length-1); i >= 0 ; --i) {
            bolas[i].update_v0();
            }
    }

     public void bolasseguirem_inverso_v0(){
    
            for (int i = 0; i < bolas.length; ++i) {
            bolas[i].update_v0();
        }
    }

 public void planodefundo(){
    //Planos de fundo
        //plano de fundo variável
            if(switch_bg==true){backgroundx++;}else{backgroundx--;}
            if(backgroundx<=0){ switch_bg = true;}
            if(backgroundx>=255){ switch_bg = false;}

            //println(switch_bg+" | "+backgroundx); //debug cor fundo
            //background(backgroundx,backgroundx,255-backgroundx);
        
        //plano de fundo simples
            background(128);
}


 public void input_pos_aleatorio(){
    pos_x=PApplet.parseInt(random(0,width));
    pos_y=PApplet.parseInt(random(0,height));
}

 public void input_mouse(){
    pos_x = mouseX;
    pos_y = mouseY;
}


  public void settings() { fullScreen(P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "V5" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
